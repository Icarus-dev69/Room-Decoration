<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@master/dist/aframe-master.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="
    https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js
    "></script>
    <style>
      .model-thumb {
        height: 80px;
        margin: 5px;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 8px;
      }
      .model-thumb.selected {
        border-color: #0077ff;
      }
    </style>
  </head>

  <body style="margin: 0; overflow: hidden">
    <!-- <div style="position: absolute; top: 10px; left: 10px; z-index: 9999;">
      <button id="moveMode">Move</button>
      <button id="rotateXMode">Rotate X</button>
      <button id="rotateYMode">Rotate Y</button>
    </div> -->
    <select id="mode-selector" style="position: absolute; top: 10px; left: 10px; z-index: 9999; font-size:16px; padding:4px;">
      <option value="move">Move</option>
      <option value="scale">Scale</option>
      <option value="rotateX">Rotate X</option>
      <option value="rotateY">Rotate Y</option>
    </select>
    <button id="take-picture-btn" style="
  position: absolute;
  bottom: 90px;
  left: 50%;
  transform: translateX(-50%);
  padding: 12px 20px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  z-index: 9999;
">Take Picture</button>

<div id="countdown-text" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
  font-weight: bold;
  color: red;
  z-index: 9999;
  display: none;
  text-align: center;
">Please stay still</div>
    <a-scene
    id="scene"
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false;"
      renderer="preserveDrawingBuffer: false;"
      vr-mode-ui="enabled: false"
      preserve-buffer
    >
    <!-- <a-box position="0 1 -3" color="red"></a-box> -->
      <!-- Camera -->
      <a-entity id="camera" class="video" camera position="0 1.6 0"></a-entity>

      <a-entity id="raycaster" raycaster="objects: #ground"></a-entity>


      <!-- Invisible ground to receive touch interactions -->
      <a-plane
        id="ground"
        rotation="-90 0 0"
        width="10"
        height="10"
        visible="false"
      ></a-plane>



    </a-scene>
    <div id="model-selector" style="position: absolute; bottom: 10px; left: 0; right: 0; display: flex; overflow-x: auto; z-index: 9999;">
      <img src="assets/thumbnails/test1.png" data-model="assets/models/test.glb" class="model-thumb" />
      <img src="assets/thumbnails/test2.png" data-model="assets/models/test2.glb" class="model-thumb" />
      <!-- Add more models as needed -->
    </div>
    
    
    

    <script>
      AFRAME.registerComponent('preserve-buffer', {
        init: function () {
          this.el.renderer.preserveDrawingBuffer = true;
        }
      });
      const modeSelector = document.getElementById("mode-selector");
      let mode = modeSelector.value; // default

      modeSelector.addEventListener("change", () => {
        mode = modeSelector.value;
        console.log("Mode changed to:", mode);
      });

      let activeFurniture = null;
      let scene = document.querySelector("a-scene");

      // Touch interaction
      let touchStartX = 0;
      let touchStartY = 0;
      let initialPos = null;
      let initialRot = null;

      let initialDistance = null;
      let initialScale = null;

      // Model selection
      document.querySelectorAll(".model-thumb").forEach((img) => {
        img.addEventListener("click", () => {
          document.querySelectorAll(".model-thumb").forEach((i) => i.classList.remove("selected"));
          img.classList.add("selected");

          const modelUrl = img.getAttribute("data-model");
          const newFurniture = document.createElement("a-entity");
          newFurniture.setAttribute("gltf-model", modelUrl);
          newFurniture.setAttribute("scale", "0.1 0.1 0.1");
          newFurniture.setAttribute("position", "0 0 -4");
          newFurniture.setAttribute("auto-bounds", "");
          newFurniture.classList.add("furniture-item");

          scene.appendChild(newFurniture);
          setActiveFurniture(newFurniture);
        });
      });

      // Tap to select placed model
      scene.addEventListener("click", (e) => {
        const target = e.target;
        if (target.classList.contains("furniture-item")) {
          setActiveFurniture(target);
        }
      });

      function setActiveFurniture(el) {
        activeFurniture = el;
      }

      // Touch start
      scene.addEventListener("touchstart", (e) => {
        if (!activeFurniture) return;

        if (e.touches.length === 1) {
          const touch = e.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
          initialPos = Object.assign({}, activeFurniture.getAttribute("position"));
          initialRot = Object.assign({}, activeFurniture.getAttribute("rotation"));
        }

        if (e.touches.length === 2 && mode === "scale") {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          initialDistance = Math.sqrt(dx * dx + dy * dy);
          initialScale = Object.assign({}, activeFurniture.getAttribute("scale"));
        }
      });

      // Touch move
      scene.addEventListener("touchmove", (e) => {
        if (!activeFurniture) return;
        e.preventDefault();

        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const dx = touch.clientX - touchStartX;
          const dy = touch.clientY - touchStartY;

          if (mode === "move") {
          const scaleFactor = 0.01;
          const newX = initialPos.x + dx * scaleFactor;
          const newY = initialPos.y + dy * -scaleFactor; // negative to match screen direction
          activeFurniture.setAttribute("position", { x: newX, y: newY, z: initialPos.z });
        } else if (mode === "rotateY") {
            const newRotX = initialRot.x + dy * 0.5;
            activeFurniture.setAttribute("rotation", {
              x: newRotX,
              y: initialRot.y,
              z: initialRot.z,
            });
          } else if (mode === "rotateX") {
            const newRotY = initialRot.y + dx * 0.5;
            activeFurniture.setAttribute("rotation", {
              x: initialRot.x,
              y: newRotY,
              z: initialRot.z,
            });
          }
        }

        if (e.touches.length === 2 && mode === "scale" && initialDistance) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentDistance = Math.sqrt(dx * dx + dy * dy);
          const scaleFactor = currentDistance / initialDistance;

          const newScale = {
            x: initialScale.x * scaleFactor,
            y: initialScale.y * scaleFactor,
            z: initialScale.z * scaleFactor,
          };

          const minScale = 0.001;
          const maxScale = 5;

          newScale.x = Math.min(maxScale, Math.max(minScale, newScale.x));
          newScale.y = Math.min(maxScale, Math.max(minScale, newScale.y));
          newScale.z = Math.min(maxScale, Math.max(minScale, newScale.z));

          activeFurniture.setAttribute("scale", newScale);
        }
      });

      const takePicBtn = document.getElementById("take-picture-btn");
const countdownText = document.getElementById("countdown-text");

takePicBtn.addEventListener("click", () => {
  countdownText.style.display = "block";
  countdownText.innerText = "3";

  let counter = 3;
  const interval = setInterval(() => {
    counter--;
    if (counter > 0) {
      countdownText.innerText = counter;
    } else {
      countdownText.innerText = "Please stay still";
    }
  }, 1000);

  setTimeout(() => {
    clearInterval(interval);
    countdownText.style.display = "none";

    // Take the screenshot
    takeARScreenshot();
  }, 4000); // 3 sec countdown + 1 sec for "Please stay still"
});


function takeARScreenshot() {
  const sceneEl = document.querySelector("#scene");
  const renderer = sceneEl.renderer;
  const canvas3D = renderer.domElement;
  const video = document.querySelector("video"); // AR.js camera feed

  // Make sure renderer has rendered the latest frame
  renderer.render(sceneEl.object3D, sceneEl.camera);

  // Prepare output canvas
  const finalCanvas = document.createElement("canvas");
  finalCanvas.width = canvas3D.width;
  finalCanvas.height = canvas3D.height;
  const ctx = finalCanvas.getContext("2d");

  // 1. Draw camera video as background
  if (video) {
    ctx.drawImage(video, 0, 0, finalCanvas.width, finalCanvas.height);
  }

  // 2. Draw the WebGL scene
  ctx.drawImage(canvas3D, 0, 0, finalCanvas.width, finalCanvas.height);

  // 3. Save as PNG
  finalCanvas.toBlob((blob) => {
    if (!blob) {
      console.error("Failed to capture AR screenshot");
      return;
    }
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `ar_screenshot_${Date.now()}.png`;
    link.click();
    URL.revokeObjectURL(url);
  }, "image/png");
}
    </script>

  </body>
</html>